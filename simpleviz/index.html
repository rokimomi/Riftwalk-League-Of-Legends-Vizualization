<!DOCTYPE html>
<meta charset="utf-8">
<style>

svg {
  font: 10px sans-serif;
  padding: 10px;
}

.axis,
.frame {
  shape-rendering: crispEdges;
}

.axis line {
  stroke: #ddd;
}

.axis path {
  display: none;
}

.frame {
  fill: none;
  stroke: #aaa;
}

circle {
  fill-opacity: .7;
}

circle.hidden {
  fill: #ccc !important;
}

.extent {
  fill: #000;
  fill-opacity: .125;
  stroke: #fff;
}

#filters {
	
	width: 300 px;
	display: inline-block;
	vertical-align: top;
	margin-top: 25px;
	padding: 10px;
	border: solid 1px black;
}

.tooltip {   
	position: absolute;           
	width: 250px;                  
	height: 100px;                 
	padding: 10px;             
	font-size: 11px;        
	background: #FFDBBB;   
	border-radius: 10px; 
	border: 0px;                
	pointer-events: none;
	opacity: 0;
}

</style>
<body>

<h1>Scatterplot Matrix Visualization</h1>

<span id="filters">

	<form>

		<strong>Color By:</strong> <br/>

		<input id="winlose" type="radio" name="color" value="winlose" checked="checked"> Win / Loss<br>
		<input id="bluered" type="radio" name="color" value="bluered"> Blue Side / Red Side

		<br/><br/>

		<strong>Include Variables:</strong> <br/>
		<input id="goldCheck" type="checkbox" checked="checked">
		Gold (k) <br/>
		<input id="creepscoreCheck" type="checkbox" checked="checked">
		Creep Score <br/>
		<input id="wardsCheck" type="checkbox" checked="checked">
		Wards <br/>
		<input id="baronkillsCheck" type="checkbox">
		Baron Kills <br/>
		<input id="dragonkillsCheck" type="checkbox">
		Dragon Kills<br/>
		<input id="wonCheck" type="checkbox" checked="checked">
		Game Won/Lost (1/0)
        

</form>

</span>

<span id="plots"></span>

<span class="tooltip">TOOLTIP_PLACEHOLDER</span>

<br/><br/>
---
<br/><br/>

<strong>Amine Boudalia - SI 649 - 2014</strong><br>
All data belongs to <a href="http://www.riftwalk.gg"><strong>riftwalk.gg</strong></a>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 960,
    size = 150,
    padding = 19.5;

var x = d3.scale.linear()
    .range([padding / 2, size - padding / 2]);

var y = d3.scale.linear()
    .range([size - padding / 2, padding / 2]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .ticks(5);

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(5);

var color = d3.scale.category10();

var filterColor = "winlose";

var columnsList = [];

function columListRefresh(){

	columnsList = [];

	if(colorCheck)
		columnsList.push("Color");
	
	if(goldCheck)
		columnsList.push("Gold");
		
	if(creepscoreCheck)
		columnsList.push("Creep Score");
		
	if(wardsCheck)
		columnsList.push("Wards");
		
	if(baronkillsCheck)
		columnsList.push("Baron Kills");
	
	if(dragonkillsCheck)
		columnsList.push("Dragon Kills");
		
	if(wonCheck)
		columnsList.push("Won");
		
}

var colorCheck = false;
var goldCheck = true;
var creepscoreCheck = true;
var wardsCheck = true;
var baronkillsCheck = false;
var dragonkillsCheck = false;
var wonCheck = true;

  
  function arrayContains(needle, arrhaystack) {
	return (arrhaystack.indexOf(needle) > -1);
  }
  
d3.csv("league.csv", function(error, data) {
	
	render();

	function render() {

	  d3.select("svg").remove();
	
	  columListRefresh();
	
	  var domainByTrait = {},
		  traits = d3.keys(data[0]).filter(function(d) { return (arrayContains(d, columnsList)); }),
		  n = traits.length;

	  traits.forEach(function(trait) {
		domainByTrait[trait] = d3.extent(data, function(d) { return d[trait]; });
	  });

	  xAxis.tickSize(size * n);
	  yAxis.tickSize(-size * n);

	  var brush = d3.svg.brush()
		  .x(x)
		  .y(y)
		  .on("brushstart", brushstart)
		  .on("brush", brushmove)
		  .on("brushend", brushend);

	  var svg = d3.select("#plots").append("svg")
		  .attr("width", size * n + padding)
		  .attr("height", size * n + padding)
		.append("g")
		  .attr("transform", "translate(" + padding + "," + padding / 2 + ")");

	  svg.selectAll(".x.axis")
		  .data(traits)
		.enter().append("g")
		  .attr("class", "x axis")
		  .attr("transform", function(d, i) { return "translate(" + (n - i - 1) * size + ",0)"; })
		  .each(function(d) { x.domain(domainByTrait[d]); d3.select(this).call(xAxis); });

	  svg.selectAll(".y.axis")
		  .data(traits)
		.enter().append("g")
		  .attr("class", "y axis")
		  .attr("transform", function(d, i) { return "translate(0," + i * size + ")"; })
		  .each(function(d) { y.domain(domainByTrait[d]); d3.select(this).call(yAxis); });
		  
	  var cell = svg.selectAll(".cell")
		  .data(cross(traits, traits))
		.enter().append("g")
		  .attr("class", "cell")
		  .attr("transform", function(d) { return "translate(" + (n - d.i - 1) * size + "," + d.j * size + ")"; })
		  .each(plot);

	  // Titles for the diagonal.
	  cell.filter(function(d) { return d.i === d.j; }).append("text")
		  .attr("x", padding)
		  .attr("y", padding)
		  .attr("dy", ".71em")
		  .text(function(d) { return d.x; });

	  cell.call(brush);

	  function plot(p) {
	  
		var cell = d3.select(this);

		x.domain(domainByTrait[p.x]);
		y.domain(domainByTrait[p.y]);

		cell.append("rect")
			.attr("class", "frame")
			.attr("x", padding / 2)
			.attr("y", padding / 2)
			.attr("width", size - padding)
			.attr("height", size - padding);

		cell.selectAll("circle")
			.data(data)
		  .enter().append("circle")
			.attr("cx", function(d) { return x(d[p.x]); })
			.attr("cy", function(d) { return y(d[p.y]); })
			.attr("r", 3)
			
			.style("fill", function(d) { 
				
				if(filterColor == "winlose")
					return color(d["Won"]); 
				else if(filterColor == "bluered")
					return color(d["Color"]);
			});
	  }
	  
	  var brushCell;

	  // Clear the previously-active brush, if any.
	  function brushstart(p) {
		if (brushCell !== this) {
		  d3.select(brushCell).call(brush.clear());
		  x.domain(domainByTrait[p.x]);
		  y.domain(domainByTrait[p.y]);
		  brushCell = this;
		}
	  }

	  // Highlight the selected circles.
	  function brushmove(p) {
		var e = brush.extent();
		svg.selectAll("circle").classed("hidden", function(d) {
		  return e[0][0] > d[p.x] || d[p.x] > e[1][0]
			  || e[0][1] > d[p.y] || d[p.y] > e[1][1];
		});
	  }

	  // If the brush is empty, select all circles.
	  function brushend() {
		if (brush.empty()) svg.selectAll(".hidden").classed("hidden", false);
	  }

	  function cross(a, b) {
		var c = [], n = a.length, m = b.length, i, j;
		for (i = -1; ++i < n;) for (j = -1; ++j < m;) c.push({x: a[i], i: i, y: b[j], j: j});
		return c;
	  }


	  d3.select(self.frameElement).style("height", size * n + padding + 20 + "px");
  
	  // color updating
  
	  function changeColor(p) {
	  
		var cell3 = d3.select(this);

		cell3.selectAll("circle")
			.data(data)
			.transition()
			.style("fill", function(d) { 
				if(filterColor == "winlose")
					return color(d["Won"]); 
				else if(filterColor == "bluered")
					return color(d["Color"]);
			});
			
	  }
	  
		d3.select("#winlose").on("click", function() {
		  filterColor = "winlose";
		  var cell2 = svg.selectAll(".cell")
		  .data(cross(traits, traits))
		  .each(changeColor);
	  });
	  
	  d3.select("#bluered").on("click", function() {
		  filterColor = "bluered";
		  var cell2 = svg.selectAll(".cell")
		  .data(cross(traits, traits))
		  .each(changeColor);
	  });
	  
	// filters
	
	d3.select("#colorCheck").on("click", function() {
		 colorCheck = d3.select(this).node().checked;
		 render();
    });
	d3.select("#goldCheck").on("click", function() {
		 goldCheck = d3.select(this).node().checked;
		 render();
    });
	d3.select("#creepscoreCheck").on("click", function() {
		 creepscoreCheck = d3.select(this).node().checked;
		 render();
    });
	d3.select("#wardsCheck").on("click", function() {
		 wardsCheck = d3.select(this).node().checked;
		 render();
    });
	d3.select("#baronkillsCheck").on("click", function() {
		 baronkillsCheck = d3.select(this).node().checked;
		 render();
    });
	d3.select("#dragonkillsCheck").on("click", function() {
		 dragonkillsCheck = d3.select(this).node().checked;
		 render();
    });
	d3.select("#wonCheck").on("click", function() {
		 wonCheck = d3.select(this).node().checked;
		 render();
    });
	
	// tool tips
	
	function mouseOverToolTip(d,i) {
		d3.select(".tooltip")
			.transition()
			.style("opacity", 1);
	}
	
	function mouseOutToolTip(d, i) {
		d3.select(".tooltip")
			.transition()
			.style("opacity", 1e-6);
	}
  
  }
  
  
  
  
  
  
});









  

</script>